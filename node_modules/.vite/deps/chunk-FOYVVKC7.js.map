{
  "version": 3,
  "sources": ["../../@protobuf-ts/runtime-rpc/build/es2015/reflection-info.js", "../../@protobuf-ts/runtime-rpc/build/es2015/service-type.js", "../../@protobuf-ts/runtime-rpc/build/es2015/rpc-error.js", "../../@protobuf-ts/runtime-rpc/build/es2015/rpc-options.js", "../../@protobuf-ts/runtime-rpc/build/es2015/deferred.js", "../../@protobuf-ts/runtime-rpc/build/es2015/rpc-output-stream.js", "../../@protobuf-ts/runtime-rpc/build/es2015/unary-call.js", "../../@protobuf-ts/runtime-rpc/build/es2015/server-streaming-call.js", "../../@protobuf-ts/runtime-rpc/build/es2015/client-streaming-call.js", "../../@protobuf-ts/runtime-rpc/build/es2015/duplex-streaming-call.js", "../../@protobuf-ts/runtime-rpc/build/es2015/test-transport.js", "../../@protobuf-ts/runtime-rpc/build/es2015/rpc-interceptor.js", "../../@protobuf-ts/runtime-rpc/build/es2015/server-call-context.js"],
  "sourcesContent": ["import { lowerCamelCase } from \"@protobuf-ts/runtime\";\n/**\n * Turns PartialMethodInfo into MethodInfo.\n */\nexport function normalizeMethodInfo(method, service) {\n    var _a, _b, _c;\n    let m = method;\n    m.service = service;\n    m.localName = (_a = m.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(m.name);\n    // noinspection PointlessBooleanExpressionJS\n    m.serverStreaming = !!m.serverStreaming;\n    // noinspection PointlessBooleanExpressionJS\n    m.clientStreaming = !!m.clientStreaming;\n    m.options = (_b = m.options) !== null && _b !== void 0 ? _b : {};\n    m.idempotency = (_c = m.idempotency) !== null && _c !== void 0 ? _c : undefined;\n    return m;\n}\n/**\n * Read custom method options from a generated service client.\n *\n * @deprecated use readMethodOption()\n */\nexport function readMethodOptions(service, methodName, extensionName, extensionType) {\n    var _a;\n    const options = (_a = service.methods.find((m, i) => m.localName === methodName || i === methodName)) === null || _a === void 0 ? void 0 : _a.options;\n    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;\n}\nexport function readMethodOption(service, methodName, extensionName, extensionType) {\n    var _a;\n    const options = (_a = service.methods.find((m, i) => m.localName === methodName || i === methodName)) === null || _a === void 0 ? void 0 : _a.options;\n    if (!options) {\n        return undefined;\n    }\n    const optionVal = options[extensionName];\n    if (optionVal === undefined) {\n        return optionVal;\n    }\n    return extensionType ? extensionType.fromJson(optionVal) : optionVal;\n}\nexport function readServiceOption(service, extensionName, extensionType) {\n    const options = service.options;\n    if (!options) {\n        return undefined;\n    }\n    const optionVal = options[extensionName];\n    if (optionVal === undefined) {\n        return optionVal;\n    }\n    return extensionType ? extensionType.fromJson(optionVal) : optionVal;\n}\n", "import { normalizeMethodInfo } from \"./reflection-info\";\nexport class ServiceType {\n    constructor(typeName, methods, options) {\n        this.typeName = typeName;\n        this.methods = methods.map(i => normalizeMethodInfo(i, this));\n        this.options = options !== null && options !== void 0 ? options : {};\n    }\n}\n", "/**\n * An error that occurred while calling a RPC method.\n */\nexport class RpcError extends Error {\n    constructor(message, code = 'UNKNOWN', meta) {\n        super(message);\n        this.name = 'RpcError';\n        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#example\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.code = code;\n        this.meta = meta !== null && meta !== void 0 ? meta : {};\n    }\n    toString() {\n        const l = [this.name + ': ' + this.message];\n        if (this.code) {\n            l.push('');\n            l.push('Code: ' + this.code);\n        }\n        if (this.serviceName && this.methodName) {\n            l.push('Method: ' + this.serviceName + '/' + this.methodName);\n        }\n        let m = Object.entries(this.meta);\n        if (m.length) {\n            l.push('');\n            l.push('Meta:');\n            for (let [k, v] of m) {\n                l.push(`  ${k}: ${v}`);\n            }\n        }\n        return l.join('\\n');\n    }\n}\n", "import { mergeBinaryOptions, mergeJsonOptions } from \"@protobuf-ts/runtime\";\n/**\n * Merges custom RPC options with defaults. Returns a new instance and keeps\n * the \"defaults\" and the \"options\" unmodified.\n *\n * Merges `RpcMetadata` \"meta\", overwriting values from \"defaults\" with\n * values from \"options\". Does not append values to existing entries.\n *\n * Merges \"jsonOptions\", including \"jsonOptions.typeRegistry\", by creating\n * a new array that contains types from \"options.jsonOptions.typeRegistry\"\n * first, then types from \"defaults.jsonOptions.typeRegistry\".\n *\n * Merges \"binaryOptions\".\n *\n * Merges \"interceptors\" by creating a new array that contains interceptors\n * from \"defaults\" first, then interceptors from \"options\".\n *\n * Works with objects that extend `RpcOptions`, but only if the added\n * properties are of type Date, primitive like string, boolean, or Array\n * of primitives. If you have other property types, you have to merge them\n * yourself.\n */\nexport function mergeRpcOptions(defaults, options) {\n    if (!options)\n        return defaults;\n    let o = {};\n    copy(defaults, o);\n    copy(options, o);\n    for (let key of Object.keys(options)) {\n        let val = options[key];\n        switch (key) {\n            case \"jsonOptions\":\n                o.jsonOptions = mergeJsonOptions(defaults.jsonOptions, o.jsonOptions);\n                break;\n            case \"binaryOptions\":\n                o.binaryOptions = mergeBinaryOptions(defaults.binaryOptions, o.binaryOptions);\n                break;\n            case \"meta\":\n                o.meta = {};\n                copy(defaults.meta, o.meta);\n                copy(options.meta, o.meta);\n                break;\n            case \"interceptors\":\n                o.interceptors = defaults.interceptors ? defaults.interceptors.concat(val) : val.concat();\n                break;\n        }\n    }\n    return o;\n}\nfunction copy(a, into) {\n    if (!a)\n        return;\n    let c = into;\n    for (let [k, v] of Object.entries(a)) {\n        if (v instanceof Date)\n            c[k] = new Date(v.getTime());\n        else if (Array.isArray(v))\n            c[k] = v.concat();\n        else\n            c[k] = v;\n    }\n}\n", "export var DeferredState;\n(function (DeferredState) {\n    DeferredState[DeferredState[\"PENDING\"] = 0] = \"PENDING\";\n    DeferredState[DeferredState[\"REJECTED\"] = 1] = \"REJECTED\";\n    DeferredState[DeferredState[\"RESOLVED\"] = 2] = \"RESOLVED\";\n})(DeferredState || (DeferredState = {}));\n/**\n * A deferred promise. This is a \"controller\" for a promise, which lets you\n * pass a promise around and reject or resolve it from the outside.\n *\n * Warning: This class is to be used with care. Using it can make code very\n * difficult to read. It is intended for use in library code that exposes\n * promises, not for regular business logic.\n */\nexport class Deferred {\n    /**\n     * @param preventUnhandledRejectionWarning - prevents the warning\n     * \"Unhandled Promise rejection\" by adding a noop rejection handler.\n     * Working with calls returned from the runtime-rpc package in an\n     * async function usually means awaiting one call property after\n     * the other. This means that the \"status\" is not being awaited when\n     * an earlier await for the \"headers\" is rejected. This causes the\n     * \"unhandled promise reject\" warning. A more correct behaviour for\n     * calls might be to become aware whether at least one of the\n     * promises is handled and swallow the rejection warning for the\n     * others.\n     */\n    constructor(preventUnhandledRejectionWarning = true) {\n        this._state = DeferredState.PENDING;\n        this._promise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        if (preventUnhandledRejectionWarning) {\n            this._promise.catch(_ => { });\n        }\n    }\n    /**\n     * Get the current state of the promise.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Get the deferred promise.\n     */\n    get promise() {\n        return this._promise;\n    }\n    /**\n     * Resolve the promise. Throws if the promise is already resolved or rejected.\n     */\n    resolve(value) {\n        if (this.state !== DeferredState.PENDING)\n            throw new Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);\n        this._resolve(value);\n        this._state = DeferredState.RESOLVED;\n    }\n    /**\n     * Reject the promise. Throws if the promise is already resolved or rejected.\n     */\n    reject(reason) {\n        if (this.state !== DeferredState.PENDING)\n            throw new Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);\n        this._reject(reason);\n        this._state = DeferredState.REJECTED;\n    }\n    /**\n     * Resolve the promise. Ignore if not pending.\n     */\n    resolvePending(val) {\n        if (this._state === DeferredState.PENDING)\n            this.resolve(val);\n    }\n    /**\n     * Reject the promise. Ignore if not pending.\n     */\n    rejectPending(reason) {\n        if (this._state === DeferredState.PENDING)\n            this.reject(reason);\n    }\n}\n", "import { Deferred, DeferredState } from \"./deferred\";\nimport { assert } from \"@protobuf-ts/runtime\";\n/**\n * A `RpcOutputStream` that you control.\n */\nexport class RpcOutputStreamController {\n    constructor() {\n        this._lis = {\n            nxt: [],\n            msg: [],\n            err: [],\n            cmp: [],\n        };\n        this._closed = false;\n    }\n    // --- RpcOutputStream callback API\n    onNext(callback) {\n        return this.addLis(callback, this._lis.nxt);\n    }\n    onMessage(callback) {\n        return this.addLis(callback, this._lis.msg);\n    }\n    onError(callback) {\n        return this.addLis(callback, this._lis.err);\n    }\n    onComplete(callback) {\n        return this.addLis(callback, this._lis.cmp);\n    }\n    addLis(callback, list) {\n        list.push(callback);\n        return () => {\n            let i = list.indexOf(callback);\n            if (i >= 0)\n                list.splice(i, 1);\n        };\n    }\n    // remove all listeners\n    clearLis() {\n        for (let l of Object.values(this._lis))\n            l.splice(0, l.length);\n    }\n    // --- Controller API\n    /**\n     * Is this stream already closed by a completion or error?\n     */\n    get closed() {\n        return this._closed !== false;\n    }\n    /**\n     * Emit message, close with error, or close successfully, but only one\n     * at a time.\n     * Can be used to wrap a stream by using the other stream's `onNext`.\n     */\n    notifyNext(message, error, complete) {\n        assert((message ? 1 : 0) + (error ? 1 : 0) + (complete ? 1 : 0) <= 1, 'only one emission at a time');\n        if (message)\n            this.notifyMessage(message);\n        if (error)\n            this.notifyError(error);\n        if (complete)\n            this.notifyComplete();\n    }\n    /**\n     * Emits a new message. Throws if stream is closed.\n     *\n     * Triggers onNext and onMessage callbacks.\n     */\n    notifyMessage(message) {\n        assert(!this.closed, 'stream is closed');\n        this.pushIt({ value: message, done: false });\n        this._lis.msg.forEach(l => l(message));\n        this._lis.nxt.forEach(l => l(message, undefined, false));\n    }\n    /**\n     * Closes the stream with an error. Throws if stream is closed.\n     *\n     * Triggers onNext and onError callbacks.\n     */\n    notifyError(error) {\n        assert(!this.closed, 'stream is closed');\n        this._closed = error;\n        this.pushIt(error);\n        this._lis.err.forEach(l => l(error));\n        this._lis.nxt.forEach(l => l(undefined, error, false));\n        this.clearLis();\n    }\n    /**\n     * Closes the stream successfully. Throws if stream is closed.\n     *\n     * Triggers onNext and onComplete callbacks.\n     */\n    notifyComplete() {\n        assert(!this.closed, 'stream is closed');\n        this._closed = true;\n        this.pushIt({ value: null, done: true });\n        this._lis.cmp.forEach(l => l());\n        this._lis.nxt.forEach(l => l(undefined, undefined, true));\n        this.clearLis();\n    }\n    /**\n     * Creates an async iterator (that can be used with `for await {...}`)\n     * to consume the stream.\n     *\n     * Some things to note:\n     * - If an error occurs, the `for await` will throw it.\n     * - If an error occurred before the `for await` was started, `for await`\n     *   will re-throw it.\n     * - If the stream is already complete, the `for await` will be empty.\n     * - If your `for await` consumes slower than the stream produces,\n     *   for example because you are relaying messages in a slow operation,\n     *   messages are queued.\n     */\n    [Symbol.asyncIterator]() {\n        // init the iterator state, enabling pushIt()\n        if (!this._itState) {\n            this._itState = { q: [] };\n        }\n        // if we are closed, we are definitely not receiving any more messages.\n        // but we can't let the iterator get stuck. we want to either:\n        // a) finish the new iterator immediately, because we are completed\n        // b) reject the new iterator, because we errored\n        if (this._closed === true)\n            this.pushIt({ value: null, done: true });\n        else if (this._closed !== false)\n            this.pushIt(this._closed);\n        // the async iterator\n        return {\n            next: () => {\n                let state = this._itState;\n                assert(state, \"bad state\"); // if we don't have a state here, code is broken\n                // there should be no pending result.\n                // did the consumer call next() before we resolved our previous result promise?\n                assert(!state.p, \"iterator contract broken\");\n                // did we produce faster than the iterator consumed?\n                // return the oldest result from the queue.\n                let first = state.q.shift();\n                if (first)\n                    return (\"value\" in first) ? Promise.resolve(first) : Promise.reject(first);\n                // we have no result ATM, but we promise one.\n                // as soon as we have a result, we must resolve promise.\n                state.p = new Deferred();\n                return state.p.promise;\n            },\n        };\n    }\n    // \"push\" a new iterator result.\n    // this either resolves a pending promise, or enqueues the result.\n    pushIt(result) {\n        let state = this._itState;\n        if (!state)\n            return;\n        // is the consumer waiting for us?\n        if (state.p) {\n            // yes, consumer is waiting for this promise.\n            const p = state.p;\n            assert(p.state == DeferredState.PENDING, \"iterator contract broken\");\n            // resolve the promise\n            (\"value\" in result) ? p.resolve(result) : p.reject(result);\n            // must cleanup, otherwise iterator.next() would pick it up again.\n            delete state.p;\n        }\n        else {\n            // we are producing faster than the iterator consumes.\n            // push result onto queue.\n            state.q.push(result);\n        }\n    }\n}\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * A unary RPC call. Unary means there is exactly one input message and\n * exactly one output message unless an error occurred.\n */\nexport class UnaryCall {\n    constructor(method, requestHeaders, request, headers, response, status, trailers) {\n        this.method = method;\n        this.requestHeaders = requestHeaders;\n        this.request = request;\n        this.headers = headers;\n        this.response = response;\n        this.status = status;\n        this.trailers = trailers;\n    }\n    /**\n     * If you are only interested in the final outcome of this call,\n     * you can await it to receive a `FinishedUnaryCall`.\n     */\n    then(onfulfilled, onrejected) {\n        return this.promiseFinished().then(value => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, reason => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));\n    }\n    promiseFinished() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);\n            return {\n                method: this.method,\n                requestHeaders: this.requestHeaders,\n                request: this.request,\n                headers,\n                response,\n                status,\n                trailers\n            };\n        });\n    }\n}\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * A server streaming RPC call. The client provides exactly one input message\n * but the server may respond with 0, 1, or more messages.\n */\nexport class ServerStreamingCall {\n    constructor(method, requestHeaders, request, headers, response, status, trailers) {\n        this.method = method;\n        this.requestHeaders = requestHeaders;\n        this.request = request;\n        this.headers = headers;\n        this.responses = response;\n        this.status = status;\n        this.trailers = trailers;\n    }\n    /**\n     * Instead of awaiting the response status and trailers, you can\n     * just as well await this call itself to receive the server outcome.\n     * You should first setup some listeners to the `request` to\n     * see the actual messages the server replied with.\n     */\n    then(onfulfilled, onrejected) {\n        return this.promiseFinished().then(value => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, reason => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));\n    }\n    promiseFinished() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);\n            return {\n                method: this.method,\n                requestHeaders: this.requestHeaders,\n                request: this.request,\n                headers,\n                status,\n                trailers,\n            };\n        });\n    }\n}\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * A client streaming RPC call. This means that the clients sends 0, 1, or\n * more messages to the server, and the server replies with exactly one\n * message.\n */\nexport class ClientStreamingCall {\n    constructor(method, requestHeaders, request, headers, response, status, trailers) {\n        this.method = method;\n        this.requestHeaders = requestHeaders;\n        this.requests = request;\n        this.headers = headers;\n        this.response = response;\n        this.status = status;\n        this.trailers = trailers;\n    }\n    /**\n     * Instead of awaiting the response status and trailers, you can\n     * just as well await this call itself to receive the server outcome.\n     * Note that it may still be valid to send more request messages.\n     */\n    then(onfulfilled, onrejected) {\n        return this.promiseFinished().then(value => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, reason => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));\n    }\n    promiseFinished() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);\n            return {\n                method: this.method,\n                requestHeaders: this.requestHeaders,\n                headers,\n                response,\n                status,\n                trailers\n            };\n        });\n    }\n}\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * A duplex streaming RPC call. This means that the clients sends an\n * arbitrary amount of messages to the server, while at the same time,\n * the server sends an arbitrary amount of messages to the client.\n */\nexport class DuplexStreamingCall {\n    constructor(method, requestHeaders, request, headers, response, status, trailers) {\n        this.method = method;\n        this.requestHeaders = requestHeaders;\n        this.requests = request;\n        this.headers = headers;\n        this.responses = response;\n        this.status = status;\n        this.trailers = trailers;\n    }\n    /**\n     * Instead of awaiting the response status and trailers, you can\n     * just as well await this call itself to receive the server outcome.\n     * Note that it may still be valid to send more request messages.\n     */\n    then(onfulfilled, onrejected) {\n        return this.promiseFinished().then(value => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, reason => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));\n    }\n    promiseFinished() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);\n            return {\n                method: this.method,\n                requestHeaders: this.requestHeaders,\n                headers,\n                status,\n                trailers,\n            };\n        });\n    }\n}\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { RpcError } from \"./rpc-error\";\nimport { assert } from \"@protobuf-ts/runtime\";\nimport { RpcOutputStreamController } from \"./rpc-output-stream\";\nimport { mergeRpcOptions } from \"./rpc-options\";\nimport { UnaryCall } from \"./unary-call\";\nimport { ServerStreamingCall } from \"./server-streaming-call\";\nimport { ClientStreamingCall } from \"./client-streaming-call\";\nimport { DuplexStreamingCall } from \"./duplex-streaming-call\";\n/**\n * Transport for testing.\n */\nexport class TestTransport {\n    /**\n     * Initialize with mock data. Omitted fields have default value.\n     */\n    constructor(data) {\n        /**\n         * Suppress warning / error about uncaught rejections of\n         * \"status\" and \"trailers\".\n         */\n        this.suppressUncaughtRejections = true;\n        this.headerDelay = 10;\n        this.responseDelay = 50;\n        this.betweenResponseDelay = 10;\n        this.afterResponseDelay = 10;\n        this.data = data !== null && data !== void 0 ? data : {};\n    }\n    /**\n     * Sent message(s) during the last operation.\n     */\n    get sentMessages() {\n        if (this.lastInput instanceof TestInputStream) {\n            return this.lastInput.sent;\n        }\n        else if (typeof this.lastInput == \"object\") {\n            return [this.lastInput.single];\n        }\n        return [];\n    }\n    /**\n     * Sending message(s) completed?\n     */\n    get sendComplete() {\n        if (this.lastInput instanceof TestInputStream) {\n            return this.lastInput.completed;\n        }\n        else if (typeof this.lastInput == \"object\") {\n            return true;\n        }\n        return false;\n    }\n    // Creates a promise for response headers from the mock data.\n    promiseHeaders() {\n        var _a;\n        const headers = (_a = this.data.headers) !== null && _a !== void 0 ? _a : TestTransport.defaultHeaders;\n        return headers instanceof RpcError\n            ? Promise.reject(headers)\n            : Promise.resolve(headers);\n    }\n    // Creates a promise for a single, valid, message from the mock data.\n    promiseSingleResponse(method) {\n        if (this.data.response instanceof RpcError) {\n            return Promise.reject(this.data.response);\n        }\n        let r;\n        if (Array.isArray(this.data.response)) {\n            assert(this.data.response.length > 0);\n            r = this.data.response[0];\n        }\n        else if (this.data.response !== undefined) {\n            r = this.data.response;\n        }\n        else {\n            r = method.O.create();\n        }\n        assert(method.O.is(r));\n        return Promise.resolve(r);\n    }\n    /**\n     * Pushes response messages from the mock data to the output stream.\n     * If an error response, status or trailers are mocked, the stream is\n     * closed with the respective error.\n     * Otherwise, stream is completed successfully.\n     *\n     * The returned promise resolves when the stream is closed. It should\n     * not reject. If it does, code is broken.\n     */\n    streamResponses(method, stream, abort) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // normalize \"data.response\" into an array of valid output messages\n            const messages = [];\n            if (this.data.response === undefined) {\n                messages.push(method.O.create());\n            }\n            else if (Array.isArray(this.data.response)) {\n                for (let msg of this.data.response) {\n                    assert(method.O.is(msg));\n                    messages.push(msg);\n                }\n            }\n            else if (!(this.data.response instanceof RpcError)) {\n                assert(method.O.is(this.data.response));\n                messages.push(this.data.response);\n            }\n            // start the stream with an initial delay.\n            // if the request is cancelled, notify() error and exit.\n            try {\n                yield delay(this.responseDelay, abort)(undefined);\n            }\n            catch (error) {\n                stream.notifyError(error);\n                return;\n            }\n            // if error response was mocked, notify() error (stream is now closed with error) and exit.\n            if (this.data.response instanceof RpcError) {\n                stream.notifyError(this.data.response);\n                return;\n            }\n            // regular response messages were mocked. notify() them.\n            for (let msg of messages) {\n                stream.notifyMessage(msg);\n                // add a short delay between responses\n                // if the request is cancelled, notify() error and exit.\n                try {\n                    yield delay(this.betweenResponseDelay, abort)(undefined);\n                }\n                catch (error) {\n                    stream.notifyError(error);\n                    return;\n                }\n            }\n            // error status was mocked, notify() error (stream is now closed with error) and exit.\n            if (this.data.status instanceof RpcError) {\n                stream.notifyError(this.data.status);\n                return;\n            }\n            // error trailers were mocked, notify() error (stream is now closed with error) and exit.\n            if (this.data.trailers instanceof RpcError) {\n                stream.notifyError(this.data.trailers);\n                return;\n            }\n            // stream completed successfully\n            stream.notifyComplete();\n        });\n    }\n    // Creates a promise for response status from the mock data.\n    promiseStatus() {\n        var _a;\n        const status = (_a = this.data.status) !== null && _a !== void 0 ? _a : TestTransport.defaultStatus;\n        return status instanceof RpcError\n            ? Promise.reject(status)\n            : Promise.resolve(status);\n    }\n    // Creates a promise for response trailers from the mock data.\n    promiseTrailers() {\n        var _a;\n        const trailers = (_a = this.data.trailers) !== null && _a !== void 0 ? _a : TestTransport.defaultTrailers;\n        return trailers instanceof RpcError\n            ? Promise.reject(trailers)\n            : Promise.resolve(trailers);\n    }\n    maybeSuppressUncaught(...promise) {\n        if (this.suppressUncaughtRejections) {\n            for (let p of promise) {\n                p.catch(() => {\n                });\n            }\n        }\n    }\n    mergeOptions(options) {\n        return mergeRpcOptions({}, options);\n    }\n    unary(method, input, options) {\n        var _a;\n        const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders()\n            .then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise\n            .catch(_ => {\n        })\n            .then(delay(this.responseDelay, options.abort))\n            .then(_ => this.promiseSingleResponse(method)), statusPromise = responsePromise\n            .catch(_ => {\n        })\n            .then(delay(this.afterResponseDelay, options.abort))\n            .then(_ => this.promiseStatus()), trailersPromise = responsePromise\n            .catch(_ => {\n        })\n            .then(delay(this.afterResponseDelay, options.abort))\n            .then(_ => this.promiseTrailers());\n        this.maybeSuppressUncaught(statusPromise, trailersPromise);\n        this.lastInput = { single: input };\n        return new UnaryCall(method, requestHeaders, input, headersPromise, responsePromise, statusPromise, trailersPromise);\n    }\n    serverStreaming(method, input, options) {\n        var _a;\n        const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders()\n            .then(delay(this.headerDelay, options.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise\n            .then(delay(this.responseDelay, options.abort))\n            .catch(() => {\n        })\n            .then(() => this.streamResponses(method, outputStream, options.abort))\n            .then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise\n            .then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise\n            .then(() => this.promiseTrailers());\n        this.maybeSuppressUncaught(statusPromise, trailersPromise);\n        this.lastInput = { single: input };\n        return new ServerStreamingCall(method, requestHeaders, input, headersPromise, outputStream, statusPromise, trailersPromise);\n    }\n    clientStreaming(method, options) {\n        var _a;\n        const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders()\n            .then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise\n            .catch(_ => {\n        })\n            .then(delay(this.responseDelay, options.abort))\n            .then(_ => this.promiseSingleResponse(method)), statusPromise = responsePromise\n            .catch(_ => {\n        })\n            .then(delay(this.afterResponseDelay, options.abort))\n            .then(_ => this.promiseStatus()), trailersPromise = responsePromise\n            .catch(_ => {\n        })\n            .then(delay(this.afterResponseDelay, options.abort))\n            .then(_ => this.promiseTrailers());\n        this.maybeSuppressUncaught(statusPromise, trailersPromise);\n        this.lastInput = new TestInputStream(this.data, options.abort);\n        return new ClientStreamingCall(method, requestHeaders, this.lastInput, headersPromise, responsePromise, statusPromise, trailersPromise);\n    }\n    duplex(method, options) {\n        var _a;\n        const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders()\n            .then(delay(this.headerDelay, options.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise\n            .then(delay(this.responseDelay, options.abort))\n            .catch(() => {\n        })\n            .then(() => this.streamResponses(method, outputStream, options.abort))\n            .then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise\n            .then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise\n            .then(() => this.promiseTrailers());\n        this.maybeSuppressUncaught(statusPromise, trailersPromise);\n        this.lastInput = new TestInputStream(this.data, options.abort);\n        return new DuplexStreamingCall(method, requestHeaders, this.lastInput, headersPromise, outputStream, statusPromise, trailersPromise);\n    }\n}\nTestTransport.defaultHeaders = {\n    responseHeader: \"test\"\n};\nTestTransport.defaultStatus = {\n    code: \"OK\", detail: \"all good\"\n};\nTestTransport.defaultTrailers = {\n    responseTrailer: \"test\"\n};\nfunction delay(ms, abort) {\n    return (v) => new Promise((resolve, reject) => {\n        if (abort === null || abort === void 0 ? void 0 : abort.aborted) {\n            reject(new RpcError(\"user cancel\", \"CANCELLED\"));\n        }\n        else {\n            const id = setTimeout(() => resolve(v), ms);\n            if (abort) {\n                abort.addEventListener(\"abort\", ev => {\n                    clearTimeout(id);\n                    reject(new RpcError(\"user cancel\", \"CANCELLED\"));\n                });\n            }\n        }\n    });\n}\nclass TestInputStream {\n    constructor(data, abort) {\n        this._completed = false;\n        this._sent = [];\n        this.data = data;\n        this.abort = abort;\n    }\n    get sent() {\n        return this._sent;\n    }\n    get completed() {\n        return this._completed;\n    }\n    send(message) {\n        if (this.data.inputMessage instanceof RpcError) {\n            return Promise.reject(this.data.inputMessage);\n        }\n        const delayMs = this.data.inputMessage === undefined\n            ? 10\n            : this.data.inputMessage;\n        return Promise.resolve(undefined)\n            .then(() => {\n            this._sent.push(message);\n        })\n            .then(delay(delayMs, this.abort));\n    }\n    complete() {\n        if (this.data.inputComplete instanceof RpcError) {\n            return Promise.reject(this.data.inputComplete);\n        }\n        const delayMs = this.data.inputComplete === undefined\n            ? 10\n            : this.data.inputComplete;\n        return Promise.resolve(undefined)\n            .then(() => {\n            this._completed = true;\n        })\n            .then(delay(delayMs, this.abort));\n    }\n}\n", "import { assertNever } from \"@protobuf-ts/runtime\";\n/**\n * Creates a \"stack\" of of all interceptors specified in the given `RpcOptions`.\n * Used by generated client implementations.\n * @internal\n */\nexport function stackIntercept(kind, transport, method, options, input) {\n    var _a, _b, _c, _d;\n    if (kind == \"unary\") {\n        let tail = (mtd, inp, opt) => transport.unary(mtd, inp, opt);\n        for (const curr of ((_a = options.interceptors) !== null && _a !== void 0 ? _a : []).filter(i => i.interceptUnary).reverse()) {\n            const next = tail;\n            tail = (mtd, inp, opt) => curr.interceptUnary(next, mtd, inp, opt);\n        }\n        return tail(method, input, options);\n    }\n    if (kind == \"serverStreaming\") {\n        let tail = (mtd, inp, opt) => transport.serverStreaming(mtd, inp, opt);\n        for (const curr of ((_b = options.interceptors) !== null && _b !== void 0 ? _b : []).filter(i => i.interceptServerStreaming).reverse()) {\n            const next = tail;\n            tail = (mtd, inp, opt) => curr.interceptServerStreaming(next, mtd, inp, opt);\n        }\n        return tail(method, input, options);\n    }\n    if (kind == \"clientStreaming\") {\n        let tail = (mtd, opt) => transport.clientStreaming(mtd, opt);\n        for (const curr of ((_c = options.interceptors) !== null && _c !== void 0 ? _c : []).filter(i => i.interceptClientStreaming).reverse()) {\n            const next = tail;\n            tail = (mtd, opt) => curr.interceptClientStreaming(next, mtd, opt);\n        }\n        return tail(method, options);\n    }\n    if (kind == \"duplex\") {\n        let tail = (mtd, opt) => transport.duplex(mtd, opt);\n        for (const curr of ((_d = options.interceptors) !== null && _d !== void 0 ? _d : []).filter(i => i.interceptDuplex).reverse()) {\n            const next = tail;\n            tail = (mtd, opt) => curr.interceptDuplex(next, mtd, opt);\n        }\n        return tail(method, options);\n    }\n    assertNever(kind);\n}\n/**\n * @deprecated replaced by `stackIntercept()`, still here to support older generated code\n */\nexport function stackUnaryInterceptors(transport, method, input, options) {\n    return stackIntercept(\"unary\", transport, method, options, input);\n}\n/**\n * @deprecated replaced by `stackIntercept()`, still here to support older generated code\n */\nexport function stackServerStreamingInterceptors(transport, method, input, options) {\n    return stackIntercept(\"serverStreaming\", transport, method, options, input);\n}\n/**\n * @deprecated replaced by `stackIntercept()`, still here to support older generated code\n */\nexport function stackClientStreamingInterceptors(transport, method, options) {\n    return stackIntercept(\"clientStreaming\", transport, method, options);\n}\n/**\n * @deprecated replaced by `stackIntercept()`, still here to support older generated code\n */\nexport function stackDuplexStreamingInterceptors(transport, method, options) {\n    return stackIntercept(\"duplex\", transport, method, options);\n}\n", "export class ServerCallContextController {\n    constructor(method, headers, deadline, sendResponseHeadersFn, defaultStatus = { code: 'OK', detail: '' }) {\n        this._cancelled = false;\n        this._listeners = [];\n        this.method = method;\n        this.headers = headers;\n        this.deadline = deadline;\n        this.trailers = {};\n        this._sendRH = sendResponseHeadersFn;\n        this.status = defaultStatus;\n    }\n    /**\n     * Set the call cancelled.\n     *\n     * Invokes all callbacks registered with onCancel() and\n     * sets `cancelled = true`.\n     */\n    notifyCancelled() {\n        if (!this._cancelled) {\n            this._cancelled = true;\n            for (let l of this._listeners) {\n                l();\n            }\n        }\n    }\n    /**\n     * Send response headers.\n     */\n    sendResponseHeaders(data) {\n        this._sendRH(data);\n    }\n    /**\n     * Is the call cancelled?\n     *\n     * When the client closes the connection before the server\n     * is done, the call is cancelled.\n     *\n     * If you want to cancel a request on the server, throw a\n     * RpcError with the CANCELLED status code.\n     */\n    get cancelled() {\n        return this._cancelled;\n    }\n    /**\n     * Add a callback for cancellation.\n     */\n    onCancel(callback) {\n        const l = this._listeners;\n        l.push(callback);\n        return () => {\n            let i = l.indexOf(callback);\n            if (i >= 0)\n                l.splice(i, 1);\n        };\n    }\n}\n"],
  "mappings": "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",
  "names": ["DeferredState", "__awaiter", "__awaiter", "__awaiter", "__awaiter"]
}
