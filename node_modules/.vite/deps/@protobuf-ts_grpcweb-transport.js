import {
  Deferred,
  RpcError,
  RpcOutputStreamController,
  ServerStreamingCall,
  UnaryCall,
  mergeRpcOptions
} from "./chunk-FOYVVKC7.js";
import {
  base64decode,
  base64encode
} from "./chunk-L5GL4MQO.js";
import "./chunk-2B2CG5KL.js";

// node_modules/@protobuf-ts/grpcweb-transport/build/es2015/goog-grpc-status-code.js
var GrpcStatusCode;
(function(GrpcStatusCode2) {
  GrpcStatusCode2[GrpcStatusCode2["OK"] = 0] = "OK";
  GrpcStatusCode2[GrpcStatusCode2["CANCELLED"] = 1] = "CANCELLED";
  GrpcStatusCode2[GrpcStatusCode2["UNKNOWN"] = 2] = "UNKNOWN";
  GrpcStatusCode2[GrpcStatusCode2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
  GrpcStatusCode2[GrpcStatusCode2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
  GrpcStatusCode2[GrpcStatusCode2["NOT_FOUND"] = 5] = "NOT_FOUND";
  GrpcStatusCode2[GrpcStatusCode2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
  GrpcStatusCode2[GrpcStatusCode2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
  GrpcStatusCode2[GrpcStatusCode2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
  GrpcStatusCode2[GrpcStatusCode2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
  GrpcStatusCode2[GrpcStatusCode2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
  GrpcStatusCode2[GrpcStatusCode2["ABORTED"] = 10] = "ABORTED";
  GrpcStatusCode2[GrpcStatusCode2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
  GrpcStatusCode2[GrpcStatusCode2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
  GrpcStatusCode2[GrpcStatusCode2["INTERNAL"] = 13] = "INTERNAL";
  GrpcStatusCode2[GrpcStatusCode2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
  GrpcStatusCode2[GrpcStatusCode2["DATA_LOSS"] = 15] = "DATA_LOSS";
})(GrpcStatusCode || (GrpcStatusCode = {}));

// node_modules/@protobuf-ts/grpcweb-transport/build/es2015/grpc-web-format.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function createGrpcWebRequestHeader(headers, format, timeout, meta, userAgent) {
  if (meta) {
    for (let [k, v] of Object.entries(meta)) {
      if (typeof v == "string")
        headers.append(k, v);
      else
        for (let i of v)
          headers.append(k, i);
    }
  }
  headers.set("Content-Type", format === "text" ? "application/grpc-web-text" : "application/grpc-web+proto");
  if (format == "text") {
    headers.set("Accept", "application/grpc-web-text");
  }
  headers.set("X-Grpc-Web", "1");
  if (userAgent)
    headers.set("X-User-Agent", userAgent);
  if (typeof timeout === "number") {
    if (timeout <= 0) {
      throw new RpcError(`timeout ${timeout} ms exceeded`, GrpcStatusCode[GrpcStatusCode.DEADLINE_EXCEEDED]);
    }
    headers.set("grpc-timeout", `${timeout}m`);
  } else if (timeout) {
    const deadline = timeout.getTime();
    const now = Date.now();
    if (deadline <= now) {
      throw new RpcError(`deadline ${timeout} exceeded`, GrpcStatusCode[GrpcStatusCode.DEADLINE_EXCEEDED]);
    }
    headers.set("grpc-timeout", `${deadline - now}m`);
  }
  return headers;
}
function createGrpcWebRequestBody(message, format) {
  let body = new Uint8Array(5 + message.length);
  body[0] = GrpcWebFrame.DATA;
  for (let msgLen = message.length, i = 4; i > 0; i--) {
    body[i] = msgLen % 256;
    msgLen >>>= 8;
  }
  body.set(message, 5);
  return format === "binary" ? body : base64encode(body);
}
function readGrpcWebResponseHeader(headersOrFetchResponse, httpStatus, httpStatusText) {
  if (arguments.length === 1) {
    let fetchResponse = headersOrFetchResponse;
    let responseType;
    try {
      responseType = fetchResponse.type;
    } catch (_a) {
    }
    switch (responseType) {
      case "error":
      case "opaque":
      case "opaqueredirect":
        throw new RpcError(`fetch response type ${fetchResponse.type}`, GrpcStatusCode[GrpcStatusCode.UNKNOWN]);
    }
    return readGrpcWebResponseHeader(fetchHeadersToHttp(fetchResponse.headers), fetchResponse.status, fetchResponse.statusText);
  }
  let headers = headersOrFetchResponse, httpOk = httpStatus >= 200 && httpStatus < 300, responseMeta = parseMetadata(headers), [statusCode, statusDetail] = parseStatus(headers);
  if ((statusCode === void 0 || statusCode === GrpcStatusCode.OK) && !httpOk) {
    statusCode = httpStatusToGrpc(httpStatus);
    statusDetail = httpStatusText;
  }
  return [statusCode, statusDetail, responseMeta];
}
function readGrpcWebResponseTrailer(data) {
  let headers = parseTrailer(data), [code, detail] = parseStatus(headers), meta = parseMetadata(headers);
  return [code !== null && code !== void 0 ? code : GrpcStatusCode.OK, detail, meta];
}
var GrpcWebFrame;
(function(GrpcWebFrame2) {
  GrpcWebFrame2[GrpcWebFrame2["DATA"] = 0] = "DATA";
  GrpcWebFrame2[GrpcWebFrame2["TRAILER"] = 128] = "TRAILER";
})(GrpcWebFrame || (GrpcWebFrame = {}));
function readGrpcWebResponseBody(stream, contentType, onFrame) {
  return __awaiter(this, void 0, void 0, function* () {
    let streamReader, base64queue = "", byteQueue = new Uint8Array(0), format = parseFormat(contentType);
    if (isReadableStream(stream)) {
      let whatWgReadableStream = stream.getReader();
      streamReader = {
        next: () => whatWgReadableStream.read()
      };
    } else {
      streamReader = stream[Symbol.asyncIterator]();
    }
    while (true) {
      let result = yield streamReader.next();
      if (result.value !== void 0) {
        if (format === "text") {
          for (let i = 0; i < result.value.length; i++)
            base64queue += String.fromCharCode(result.value[i]);
          let safeLen = base64queue.length - base64queue.length % 4;
          if (safeLen === 0)
            continue;
          byteQueue = concatBytes(byteQueue, base64decode(base64queue.substring(0, safeLen)));
          base64queue = base64queue.substring(safeLen);
        } else {
          byteQueue = concatBytes(byteQueue, result.value);
        }
        while (byteQueue.length >= 5 && byteQueue[0] === GrpcWebFrame.DATA) {
          let msgLen = 0;
          for (let i = 1; i < 5; i++)
            msgLen = (msgLen << 8) + byteQueue[i];
          if (byteQueue.length - 5 >= msgLen) {
            onFrame(GrpcWebFrame.DATA, byteQueue.subarray(5, 5 + msgLen));
            byteQueue = byteQueue.subarray(5 + msgLen);
          } else
            break;
        }
      }
      if (result.done) {
        if (byteQueue.length === 0)
          break;
        if (byteQueue[0] !== GrpcWebFrame.TRAILER || byteQueue.length < 5)
          throw new RpcError("premature EOF", GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
        onFrame(GrpcWebFrame.TRAILER, byteQueue.subarray(5));
        break;
      }
    }
  });
}
var isReadableStream = (s) => {
  return typeof s.getReader == "function";
};
function concatBytes(a, b) {
  let n = new Uint8Array(a.length + b.length);
  n.set(a);
  n.set(b, a.length);
  return n;
}
function parseFormat(contentType) {
  switch (contentType) {
    case "application/grpc-web-text":
    case "application/grpc-web-text+proto":
      return "text";
    case "application/grpc-web":
    case "application/grpc-web+proto":
      return "binary";
    case void 0:
    case null:
      throw new RpcError("missing response content type", GrpcStatusCode[GrpcStatusCode.INTERNAL]);
    default:
      throw new RpcError("unexpected response content type: " + contentType, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
  }
}
function parseStatus(headers) {
  let code, message;
  let m = headers["grpc-message"];
  if (m !== void 0) {
    if (Array.isArray(m))
      return [GrpcStatusCode.INTERNAL, "invalid grpc-web message"];
    message = m;
  }
  let s = headers["grpc-status"];
  if (s !== void 0) {
    if (Array.isArray(s))
      return [GrpcStatusCode.INTERNAL, "invalid grpc-web status"];
    code = parseInt(s, 10);
    if (GrpcStatusCode[code] === void 0)
      return [GrpcStatusCode.INTERNAL, "invalid grpc-web status"];
  }
  return [code, message];
}
function parseMetadata(headers) {
  let meta = {};
  for (let [k, v] of Object.entries(headers))
    switch (k) {
      case "grpc-message":
      case "grpc-status":
      case "content-type":
        break;
      default:
        meta[k] = v;
    }
  return meta;
}
function parseTrailer(trailerData) {
  let headers = {};
  for (let chunk of String.fromCharCode.apply(String, trailerData).trim().split("\r\n")) {
    if (chunk == "")
      continue;
    let [key, ...val] = chunk.split(":");
    const value = val.join(":").trim();
    key = key.trim();
    let e = headers[key];
    if (typeof e == "string")
      headers[key] = [e, value];
    else if (Array.isArray(e))
      e.push(value);
    else
      headers[key] = value;
  }
  return headers;
}
function fetchHeadersToHttp(fetchHeaders) {
  let headers = {};
  fetchHeaders.forEach((value, key) => {
    let e = headers[key];
    if (typeof e == "string")
      headers[key] = [e, value];
    else if (Array.isArray(e))
      e.push(value);
    else
      headers[key] = value;
  });
  return headers;
}
function httpStatusToGrpc(httpStatus) {
  switch (httpStatus) {
    case 200:
      return GrpcStatusCode.OK;
    case 400:
      return GrpcStatusCode.INVALID_ARGUMENT;
    case 401:
      return GrpcStatusCode.UNAUTHENTICATED;
    case 403:
      return GrpcStatusCode.PERMISSION_DENIED;
    case 404:
      return GrpcStatusCode.NOT_FOUND;
    case 409:
      return GrpcStatusCode.ABORTED;
    case 412:
      return GrpcStatusCode.FAILED_PRECONDITION;
    case 429:
      return GrpcStatusCode.RESOURCE_EXHAUSTED;
    case 499:
      return GrpcStatusCode.CANCELLED;
    case 500:
      return GrpcStatusCode.UNKNOWN;
    case 501:
      return GrpcStatusCode.UNIMPLEMENTED;
    case 503:
      return GrpcStatusCode.UNAVAILABLE;
    case 504:
      return GrpcStatusCode.DEADLINE_EXCEEDED;
    default:
      return GrpcStatusCode.UNKNOWN;
  }
}

// node_modules/@protobuf-ts/grpcweb-transport/build/es2015/grpc-web-transport.js
var GrpcWebFetchTransport = class {
  constructor(defaultOptions) {
    this.defaultOptions = defaultOptions;
  }
  mergeOptions(options) {
    return mergeRpcOptions(this.defaultOptions, options);
  }
  /**
   * Create an URI for a gRPC web call.
   *
   * Takes the `baseUrl` option and appends:
   * - slash "/"
   * - package name
   * - dot "."
   * - service name
   * - slash "/"
   * - method name
   *
   * If the service was declared without a package, the package name and dot
   * are omitted.
   *
   * All names are used exactly like declared in .proto.
   */
  makeUrl(method, options) {
    let base = options.baseUrl;
    if (base.endsWith("/"))
      base = base.substring(0, base.length - 1);
    return `${base}/${method.service.typeName}/${method.name}`;
  }
  clientStreaming(method) {
    const e = new RpcError("Client streaming is not supported by grpc-web", GrpcStatusCode[GrpcStatusCode.UNIMPLEMENTED]);
    e.methodName = method.name;
    e.serviceName = method.service.typeName;
    throw e;
  }
  duplex(method) {
    const e = new RpcError("Duplex streaming is not supported by grpc-web", GrpcStatusCode[GrpcStatusCode.UNIMPLEMENTED]);
    e.methodName = method.name;
    e.serviceName = method.service.typeName;
    throw e;
  }
  serverStreaming(method, input, options) {
    var _a, _b, _c, _d;
    let opt = options, format = (_a = opt.format) !== null && _a !== void 0 ? _a : "text", fetchInit = (_b = opt.fetchInit) !== null && _b !== void 0 ? _b : {}, url = this.makeUrl(method, opt), inputBytes = method.I.toBinary(input, opt.binaryOptions), defHeader = new Deferred(), responseStream = new RpcOutputStreamController(), responseEmptyBody = true, maybeStatus, defStatus = new Deferred(), maybeTrailer, defTrailer = new Deferred();
    globalThis.fetch(url, Object.assign(Object.assign({}, fetchInit), {
      method: "POST",
      headers: createGrpcWebRequestHeader(new globalThis.Headers(), format, opt.timeout, opt.meta),
      body: createGrpcWebRequestBody(inputBytes, format),
      signal: (_c = options.abort) !== null && _c !== void 0 ? _c : null
      // node-fetch@3.0.0-beta.9 rejects `undefined`
    })).then((fetchResponse) => {
      let [code, detail, meta] = readGrpcWebResponseHeader(fetchResponse);
      defHeader.resolve(meta);
      if (code != null && code !== GrpcStatusCode.OK)
        throw new RpcError(detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code], GrpcStatusCode[code], meta);
      if (code != null)
        maybeStatus = {
          code: GrpcStatusCode[code],
          detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code]
        };
      return fetchResponse;
    }).then((fetchResponse) => {
      if (!fetchResponse.body)
        throw new RpcError("missing response body", GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      return readGrpcWebResponseBody(fetchResponse.body, fetchResponse.headers.get("content-type"), (type, data) => {
        switch (type) {
          case GrpcWebFrame.DATA:
            responseStream.notifyMessage(method.O.fromBinary(data, opt.binaryOptions));
            responseEmptyBody = false;
            break;
          case GrpcWebFrame.TRAILER:
            let code, detail;
            [code, detail, maybeTrailer] = readGrpcWebResponseTrailer(data);
            maybeStatus = {
              code: GrpcStatusCode[code],
              detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code]
            };
            break;
        }
      });
    }).then(() => {
      if (!maybeTrailer && !responseEmptyBody)
        throw new RpcError(`missing trailers`, GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
      if (!maybeStatus)
        throw new RpcError(`missing status`, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      if (maybeStatus.code !== "OK")
        throw new RpcError(maybeStatus.detail, maybeStatus.code, maybeTrailer);
      responseStream.notifyComplete();
      defStatus.resolve(maybeStatus);
      defTrailer.resolve(maybeTrailer || {});
    }).catch((reason) => {
      let error;
      if (reason instanceof RpcError)
        error = reason;
      else if (reason instanceof Error && reason.name === "AbortError")
        error = new RpcError(reason.message, GrpcStatusCode[GrpcStatusCode.CANCELLED]);
      else
        error = new RpcError(reason instanceof Error ? reason.message : "" + reason, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      error.methodName = method.name;
      error.serviceName = method.service.typeName;
      defHeader.rejectPending(error);
      responseStream.notifyError(error);
      defStatus.rejectPending(error);
      defTrailer.rejectPending(error);
    });
    return new ServerStreamingCall(method, (_d = opt.meta) !== null && _d !== void 0 ? _d : {}, input, defHeader.promise, responseStream, defStatus.promise, defTrailer.promise);
  }
  unary(method, input, options) {
    var _a, _b, _c, _d;
    let opt = options, format = (_a = opt.format) !== null && _a !== void 0 ? _a : "text", fetchInit = (_b = opt.fetchInit) !== null && _b !== void 0 ? _b : {}, url = this.makeUrl(method, opt), inputBytes = method.I.toBinary(input, opt.binaryOptions), defHeader = new Deferred(), maybeMessage, defMessage = new Deferred(), maybeStatus, defStatus = new Deferred(), maybeTrailer, defTrailer = new Deferred();
    globalThis.fetch(url, Object.assign(Object.assign({}, fetchInit), {
      method: "POST",
      headers: createGrpcWebRequestHeader(new globalThis.Headers(), format, opt.timeout, opt.meta),
      body: createGrpcWebRequestBody(inputBytes, format),
      signal: (_c = options.abort) !== null && _c !== void 0 ? _c : null
      // node-fetch@3.0.0-beta.9 rejects `undefined`
    })).then((fetchResponse) => {
      let [code, detail, meta] = readGrpcWebResponseHeader(fetchResponse);
      defHeader.resolve(meta);
      if (code != null && code !== GrpcStatusCode.OK)
        throw new RpcError(detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code], GrpcStatusCode[code], meta);
      if (code != null)
        maybeStatus = {
          code: GrpcStatusCode[code],
          detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code]
        };
      return fetchResponse;
    }).then((fetchResponse) => {
      if (!fetchResponse.body)
        throw new RpcError("missing response body", GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      return readGrpcWebResponseBody(fetchResponse.body, fetchResponse.headers.get("content-type"), (type, data) => {
        switch (type) {
          case GrpcWebFrame.DATA:
            if (maybeMessage)
              throw new RpcError(`unary call received 2nd message`, GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
            maybeMessage = method.O.fromBinary(data, opt.binaryOptions);
            break;
          case GrpcWebFrame.TRAILER:
            let code, detail;
            [code, detail, maybeTrailer] = readGrpcWebResponseTrailer(data);
            maybeStatus = {
              code: GrpcStatusCode[code],
              detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code]
            };
            break;
        }
      });
    }).then(() => {
      if (!maybeTrailer && maybeMessage)
        throw new RpcError(`missing trailers`, GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
      if (!maybeStatus)
        throw new RpcError(`missing status`, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      if (!maybeMessage && maybeStatus.code === "OK")
        throw new RpcError("expected error status", GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
      if (!maybeMessage)
        throw new RpcError(maybeStatus.detail, maybeStatus.code, maybeTrailer);
      defMessage.resolve(maybeMessage);
      if (maybeStatus.code !== "OK")
        throw new RpcError(maybeStatus.detail, maybeStatus.code, maybeTrailer);
      defStatus.resolve(maybeStatus);
      defTrailer.resolve(maybeTrailer || {});
    }).catch((reason) => {
      let error;
      if (reason instanceof RpcError)
        error = reason;
      else if (reason instanceof Error && reason.name === "AbortError")
        error = new RpcError(reason.message, GrpcStatusCode[GrpcStatusCode.CANCELLED]);
      else
        error = new RpcError(reason instanceof Error ? reason.message : "" + reason, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      error.methodName = method.name;
      error.serviceName = method.service.typeName;
      defHeader.rejectPending(error);
      defMessage.rejectPending(error);
      defStatus.rejectPending(error);
      defTrailer.rejectPending(error);
    });
    return new UnaryCall(method, (_d = opt.meta) !== null && _d !== void 0 ? _d : {}, input, defHeader.promise, defMessage.promise, defStatus.promise, defTrailer.promise);
  }
};
export {
  GrpcStatusCode,
  GrpcWebFetchTransport,
  GrpcWebFrame,
  createGrpcWebRequestBody,
  createGrpcWebRequestHeader,
  readGrpcWebResponseBody,
  readGrpcWebResponseHeader,
  readGrpcWebResponseTrailer
};
//# sourceMappingURL=@protobuf-ts_grpcweb-transport.js.map
